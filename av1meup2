#!/bin/bash

usage() {
cat - <<EOF

Usage: ${0##*/} -i <INPUT FILE> -o <OUTPUT FILE>

-h|--help:      show this help message
-i|--input:     file name for input
-o|--output:    file name for output
--start:        start time for encode (default: unset)
--duration:     duration of encode (default: unset)
--crf:          crf value (default varies with input res, 2160:22, 1080:26, 720: 30, 480: 34)
--svt-preset:   SVT-AV1 preset value (default: 7)
--svt-params:   SVT-AV1 parameters string (default: unset)
--crop:         enable crop detection (default: no)
--debug:        output commands to be run, run nothing
--oprofile:     output profile [2160, 1080, 720, 480]
--vf:           custom videofilter input
--sdr:          best effort 2020->709 color fix
--yadif:        deinterlace with yadif 
--yadifmode:    set yadif to specific mode (default: 1, send frame per field)
--nnedi:        use the power of ai to deinterlace
--ivtc:         Inverse telecine, aka pullup (assumes NTSC DVD 29.97->23.976)
--pullup:       Alias for --ivtc
--fieldmatch:   Inverse telecine a different way using fieldmatch filter
--bitdepth:     Bitdepth for pixel format (8, 10 or 12, default: 10)
--audio:        transcode audio tracks to selected codec [flac, opus, aac]
--square:       convert anamorphic to square pixels which make sense
--forcelossy:  transcode all audio tracks to selected codec
--copyhdr:     copy HDR metadata (probably doesn't work, who knows, fuck ffmpeg forever)

EOF
}

while [ $# -gt 0 ]; do
    OPT="$1"
    case "${OPT}" in
    -i|--input)
            shift
            INPUT="${1}"
            shift;;
    -o|--output)
            shift
            OUTPUT="${1}"
            shift;;
    --start)
            shift
            START="${1}"
            shift;;
    --duration)
            shift
            DURATION="${1}"
            shift;;
    --crf)
            shift
            CRF="${1}"
            shift;;
    --svt-preset)
            shift
            SVT_PRESET="${1}"
            shift;;
    --svt-params)
            shift
            SVT_PARAMS="${1}"
            shift;;
    --crop)
            CROP=1
            shift;;
    --debug)
            DEBUG=1
            shift;;
    --oprofile)
            shift
            OPROFILE="${1}"
            shift;;
    --vf)
            shift
            VIDEOFILTER="${1}"
            shift;;
    --sdr)
            SDR=1
            shift;;
    --yadif)
            YADIF=1
            shift;;
    --yadifmode)
            shift
            YADIFMODE="${1}"
            shift;;
    --nnedi)
            NNEDI=1
            shift;;
    --ivtc|--pullup)
            IVTC=1
            shift;;
    --fieldmatch)
            IVTC_FIELDMATCH=1
            shift;;
    --audio)
            shift
            AUDIO="${1}"
            shift;;
    --bitdepth)
            shift
            BITDEPTH="${1}"
            shift;;
    --square)
            SQUARE=1
            shift;;
    --forcelossy)
            FORCE_LOSSY=1
            shift;;
    --copyhdr)
            COPY_HDR=1
            shift;;
    -h|--help)
            usage
            exit;;
    *)
            echo "$0: invalid option ${1}"
            echo "$0 -h for usage options"
            usage
            exit 1;;
    esac
done

# Check for tool dependencies
SELF_FULLPATH=`realpath $0`
SELF_DIR=`dirname $SELF_FULLPATH`
if [ ! -r $SELF_DIR/toolchecker ]; then
    echo "toolchecker not found."
    exit 1
else
    . $SELF_DIR/toolchecker
fi

if [ -z "$INPUT" ] || [ -z "$OUTPUT" ]; then
    echo "Insufficient options provided."
    echo "Must supply input (-i/--input) and output (-o/--output) at minimum"
    usage
    exit 1
fi

if [ ! -s "$INPUT" ] && [[ "$INPUT" != *"%"* ]]; then
    echo "Error reading input file: $INPUT"
    exit 1
elif [ -f "$OUTPUT" ]; then
    echo "Output file exists."
    exit 1
fi

INPUT_WIDTH=`$MEDIAINFO --Output=JSON "${INPUT}" | $JQ -r '.media.track[] | select(."@type" == "Video" ).Width'`
INPUT_HEIGHT=`$MEDIAINFO --Output=JSON "${INPUT}" | $JQ -r '.media.track[] | select(."@type" == "Video" ).Height'`

if [ $SQUARE ]; then
    VF="scale=iw*sar:ih,setsar=1:1"
fi

if [ ! -z "$OPROFILE" ]; then
    case "${OPROFILE}" in
        2160)
            VF="${VF:+${VF},}scale=3840:-1"
            OP_CRF=22;;
        1080)
            VF="${VF:+${VF},}scale=1920:-1"
            OP_CRF=26;;
        900)
            VF="${VF:+${VF},}scale=1600:-1"
            OP_CRF=28;;
        810)
            VF="${VF:+${VF},}scale=1440:-1"
            OP_CRF=30;;
        720)
            VF="${VF:+${VF},}scale=1280:-1"
            OP_CRF=30;;
        480)
            VF="${VF:+${VF},}scale=720:-1"
            OP_CRF=34;;
        1440)
            VF="${VF:+${VF},}scale=-1:1080,crop=1440:1080:240:0"
            OP_CRF=26;;
        960)
            VF="${VF:+${VF},}scale=-1:720,crop=960:720:160:0"
            OP_CRF=30;;
        *)
            echo "Not a recognized output profile name."
            exit 1;;
    esac
    if [ -z "$CRF" ]; then
        CRF=$OP_CRF
    fi
elif [ -z "$CRF" -a -z "$OPROFILE" ]; then
    if [ "$INPUT_WIDTH" -gt 1920 ]; then
        CRF=22
    elif [ "$INPUT_WIDTH" -gt 1280 ]; then
        CRF=26
    elif [ "$INPUT_WIDTH" -gt 854 ]; then
        CRF=30
    else
        CRF=34
    fi
fi


BITDEPTH=${BITDEPTH:=10}
case "${BITDEPTH}" in
    12)
        PIXEL_FORMAT="yuv420p12le";;
    10)
        PIXEL_FORMAT="yuv420p10le";;
    8)
        PIXEL_FORMAT="yuv420p";;
    *)
        echo "Bitdepth ${BITDEPTH} is invalid."
        exit 1;;
esac

if [ $CROP ]; then
    echo "## Finding crop..."
    SEGMENTS=10
    CFOUTPUT=$($CROPFINDER -i "$INPUT" -s $SEGMENTS -d)

    [ $DEBUG ] && echo "$CFOUTPUT"
    CROP=$(echo "$CFOUTPUT" | tail -n1)
    IFS=':' read width height left top <<< "$(echo "$CROP" | ${AWK} -F= '{print $2}')"
    if [ $INPUT_WIDTH -eq $width ] && [ $INPUT_HEIGHT -eq $height ]; then
        echo "## No crop detected"
    else
        if [ $height -eq 1072 ]; then 
            [ $DEBUG ] && echo "The dumb eight pixel height crop, ignoring"
            height=1080
            top=0
            CROP="crop=$width:1080:$left:0"
        fi
        if [ $width -ne $INPUT_WIDTH ] && [ $height -ne $INPUT_HEIGHT ]; then
            [ $DEBUG ] && echo "Crop detected in both dimensions, that's not great"
            if [ $left -gt $top ]; then
                [ $DEBUG ] && echo "Maintaining input height ($INPUT_HEIGHT)"
                if [ $(( $height + 2 * $top )) -ne $INPUT_HEIGHT ]; then
                    GUTTERS=$(( ($INPUT_HEIGHT - $height) / 2 ))
                    PAD="pad=$width:$INPUT_HEIGHT:0:$GUTTERS"
                    CROP="$CROP,$PAD"
                    [ $DEBUG ] && echo "Evenly padding crop height ($height) back to input height ($INPUT_HEIGHT) with gutters ($GUTTERS)"
                else
                    width=$INPUT_WIDTH
                    CROP="crop=$width:$INPUT_HEIGHT:$left:0"
                    [ $DEBUG ] && echo "Using original input height ($INPUT_HEIGHT)"
                fi
            elif [ $top -gt $left ]; then
                [ $DEBUG ] && echo "Maintaining input width ($INPUT_WIDTH)"
                if [ $(( $width + 2 * $left )) -ne $INPUT_WIDTH ]; then
                    GUTTERS=$(( ($INPUT_WIDTH - $width) / 2 ))
                    PAD="pad=$INPUT_WIDTH:$height:$GUTTERS:$top"
                    CROP="$CROP,$PAD"
                    [ $DEBUG ] && echo "Evenly padding crop width ($width) back to input width ($INPUT_WIDTH) with gutters ($GUTTERS)"
                else
                    width=$INPUT_WIDTH
                    CROP="crop=$INPUT_WIDTH:$height:0:$top"
                    [ $DEBUG ] && echo "Using original input width ($INPUT_WIDTH)"
                fi
            else
                echo "## Ran out of cropping ideas. Look at this crop with your eyes, type it in with your hands."
                echo "## This is what cropfinder delivered: ${CROP}"
                exit 1
            fi
        fi
        if [ $INPUT_WIDTH -eq $width ] && [ $INPUT_HEIGHT -eq $height ]; then
            echo "## After much consideration, no crop required"
        else
            echo "## ${CROP}"
            VF="${CROP}${VF:+,${VF}}"
        fi
    fi
fi

if [ $AUDIO ]; then        
    NL=$'\n'
    AUDIO_TRACK_META=""
    TRACKS=`$MEDIAINFO --output=JSON "$INPUT" | $JQ -r '.media.track[] | select (."@type"=="Audio") | @base64'`
    IFS=$'\n'
    for TRACK in ${TRACKS}; do
        TRACK_NUMBER=`echo "${TRACK}" | base64 --decode | $JQ -r '.StreamOrder'`
        TRACK_CODEC=`echo "${TRACK}" | base64 --decode | $JQ -r '.CodecID'`
        TRACK_BITRATE=`echo "${TRACK}" | base64 --decode | $JQ -r '.BitRate'`
        TRACK_LAYOUT=`echo "${TRACK}" | base64 --decode | $JQ -r '.ChannelLayout'`
        TRACK_CHANNELS=`echo "${TRACK}" | base64 --decode | $JQ -r '.Channels'`
        TRACK_COMPMODE=`echo "${TRACK}" | base64 --decode | $JQ -r '.Compression_Mode'`
        TRACK_FORMAT=`echo "${TRACK}" | base64 --decode | $JQ -r '.Format'`
        TRACK_FORMAT_COMMERCIAL_IFANY=`echo "${TRACK}" | base64 --decode | $JQ -r '.Format_Commercial_IfAny'`
        [[ "$TRACK_FORMAT_COMMERCIAL_IFANY" =~ Atmos|DTS:X ]] && TRACK_OBJFORMAT=1 || TRACK_OBJFORMAT=0
        if [ "$TRACK_LAYOUT" = "null" ] && [ "$TRACK_CHANNELS" = "null" ]; then
            TRACK_LAYOUT=`echo "${TRACK}" | base64 --decode | $JQ -r '.ChannelLayout_Original'`
            TRACK_CHANNELS=`echo "${TRACK}" | base64 --decode | $JQ -r '.Channels_Original'`
        fi
        TRACK_META="${TRACK_NUMBER},${TRACK_CODEC},${TRACK_BITRATE},${TRACK_CHANNELS},${TRACK_LAYOUT},${TRACK_FORMAT},${TRACK_COMPMODE},${TRACK_OBJFORMAT}${NL}"
        AUDIO_TRACK_META="${AUDIO_TRACK_META}${TRACK_META}"
    done
    IFS="$O_IFS"
    AUDIO_TRACK_META=`echo "$AUDIO_TRACK_META" | sed 's/^$//g'`
    if [ $DEBUG ]; then
        echo
        echo "Input Audio Tracks"
        echo "------------------"
        echo "Track,Codec,BitRate,Channels,Layout,Format,CompMode,ObjFormat${NL}${AUDIO_TRACK_META}" | column -t -s, -o " | "
        echo
    fi

    case "${AUDIO}" in
        flac)
            while read -r i; do
                IFS=, read -r TRACK_NUMBER TRACK_CODEC TRACK_BITRATE TRACK_CHANNELS TRACK_LAYOUT TRACK_FORMAT TRACK_COMPMODE<<< $( echo "$i" )
                if [[ $FORCE_LOSSY ]] || [[ "$TRACK_COMPMODE" =~ "Lossless" ]] || [[ "$TRACK_FORMAT" =~ "PCM" ]] && [[ "$TRACK_FORMAT" != "FLAC" ]]; then
                    FLAC_FLAGS="-c:a:${TRACK_NUMBER} flac $FLAC_FLAGS"
                    OUTPUT_TRACK_META="${OUTPUT_TRACK_META}${TRACK_NUMBER},flac,${TRACK_BITRATE},${TRACK_LAYOUT},n/a${NL}"
                else
                    FLAC_FLAGS="-c:a:${TRACK_NUMBER} copy $FLAC_FLAGS"
                    OUTPUT_TRACK_META="${OUTPUT_TRACK_META}${TRACK_NUMBER},copy,${TRACK_BITRATE},${TRACK_LAYOUT},n/a${NL}"
                fi
            done < <(echo "$AUDIO_TRACK_META")
            echo "Output Audio Tracks"
            echo "------------------"
            echo "Track,Codec,BitRate,Channels,Layout${NL}${OUTPUT_TRACK_META}" | column -t -s, -o " | "
            echo
            unset IFS
            AUDIO_FLAGS="$AUDIO_FLAGS ${FLAC_FLAGS:0:-1}";;
        opus)
            while read -r i; do
                IFS=, read -r TRACK_NUMBER TRACK_CODEC TRACK_BITRATE TRACK_CHANNELS TRACK_LAYOUT TRACK_FORMAT TRACK_COMPMODE TRACK_OBJFORMAT<<< $( echo "$i" )
                TRACK_NUMBER=`echo "$TRACK_NUMBER - 1" | bc`
                if ([[ $FORCE_LOSSY ]] || [[ "$TRACK_COMPMODE" =~ "Lossless" ]] || [[ "$TRACK_FORMAT" =~ "PCM" ]]) && [ $TRACK_OBJFORMAT -eq 0 ]; then
                    BR=$(echo "$TRACK_LAYOUT" | sed -e 's~Rss\|Lss\|Rsr\|Lsr\|Rb\|Lb\|Rs\|Ls\|LFE~64~g' -e 's~Cb\|C\|Cs\|L\|Lt\|R\|Rt~128~g' | tr -s ' ' '+' | bc)
                    if [ $BR -eq 0 ]; then
                        case $TRACK_CHANNELS in
                            8|7) BR=704;;
                            6|5) BR=576;;
                            4) BR=512;;
                            3) BR=384;;
                            2) BR=256;;
                            1) BR=128;;
                            *) BR=576;;
                        esac
                    fi
                    TRACK_BITRATE="${BR}k"
                    #TRACK_FLAGS="-ab:${TRACK_NUMBER} ${TRACK_BITRATE} -metadata:${TRACK_NUMBER} title=\"Opus from ${TRACK_CODEC}\" "
                    TRACK_FLAGS="-c:a:${TRACK_NUMBER} libopus -filter:a:${TRACK_NUMBER} aformat=channel_layouts='7.1|5.1|stereo|mono' -b:a:${TRACK_NUMBER} ${TRACK_BITRATE} "
                    OPUS_FLAGS="${OPUS_FLAGS}${TRACK_FLAGS}"
                    OUTPUT_TRACK_META="${OUTPUT_TRACK_META}${TRACK_NUMBER},opus,${TRACK_BITRATE},${TRACK_CHANNELS},${TRACK_LAYOUT}${NL}"
                else
                    OPUS_FLAGS="-c:a:${TRACK_NUMBER} copy $OPUS_FLAGS"
                    OUTPUT_TRACK_META="${OUTPUT_TRACK_META}${TRACK_NUMBER},copy,${TRACK_BITRATE},${TRACK_CHANNELS},${TRACK_LAYOUT}${NL}"
                fi
            done < <(echo "$AUDIO_TRACK_META")
            echo "Output Audio Tracks"
            echo "------------------"
            echo "Track,Codec,BitRate,Channels,Layout${NL}${OUTPUT_TRACK_META}" | column -t -s, -o " | "
            echo
            unset IFS
            AUDIO_FLAGS="$AUDIO_FLAGS ${OPUS_FLAGS:0:-1}"
            ;;
        aac)
            while read -r i; do
                IFS=, read -r TRACK_NUMBER TRACK_CODEC TRACK_BITRATE TRACK_CHANNELS TRACK_LAYOUT TRACK_FORMAT TRACK_COMPMODE TRACK_OBJFORMAT<<< $( echo "$i" )
                TRACK_NUMBER=`echo "$TRACK_NUMBER - 1" | bc`
                if ([[ $FORCE_LOSSY ]] || [[ "$TRACK_COMPMODE" =~ "Lossless" ]] || [[ "$TRACK_FORMAT" =~ "PCM" ]]) && [ $TRACK_OBJFORMAT -eq 0 ]; then
                    BR=$(echo "$TRACK_LAYOUT" | sed -e 's~Rss\|Lss\|Lsr\|Rsr\|Rb\|Lb\|Rs\|Ls\|LFE~64~g' -e 's~Cb\|C\|L\|R~128~g' | tr -s ' ' '+' | bc)
                    if [ $BR -eq 0 ]; then
                        BR=576
                    fi
                    TRACK_BITRATE="${BR}k"
                    #TRACK_FLAGS="-ab:${TRACK_NUMBER} ${TRACK_BITRATE} -metadata:${TRACK_NUMBER} title=\"Opus from ${TRACK_CODEC}\" "
                    TRACK_FLAGS="-c:a:${TRACK_NUMBER} libfdk_aac -b:a:${TRACK_NUMBER} ${TRACK_BITRATE} "
                    AAC_FLAGS="${AAC_FLAGS}${TRACK_FLAGS}"
                    OUTPUT_TRACK_META="${OUTPUT_TRACK_META}${TRACK_NUMBER},aac,${TRACK_BITRATE},${TRACK_CHANNELS},${TRACK_LAYOUT}${NL}"
                else
                    AAC_FLAGS="-c:a:${TRACK_NUMBER} copy $AAC_FLAGS"
                    OUTPUT_TRACK_META="${OUTPUT_TRACK_META}${TRACK_NUMBER},copy,${TRACK_BITRATE},${TRACK_CHANNELS},${TRACK_LAYOUT}${NL}"
                fi
            done < <(echo "$AUDIO_TRACK_META")
            echo "Output Audio Tracks"
            echo "------------------"
            echo "Track,Codec,BitRate,Channels,Layout${NL}${OUTPUT_TRACK_META}" | column -t -s, -o " | "
            echo
            unset IFS
            AUDIO_FLAGS="$AUDIO_FLAGS ${AAC_FLAGS:0:-1}"
            ;;
        *)
            echo "Unknown codec: ${AUDIO}"
            exit 1;;
    esac

else
    AUDIO_FLAGS="-c:a copy"
fi

## SET GOP SIZE
## ~10x frame rate, not more than 300, 240 is probably fine for everything?
G=240

if [ -z "$SVT_PRESET" ]; then
    SVT_PRESET=7
fi

if [ ! -z "$SVT_PARAMS" ]; then
    SVTAV1_PARAMS="${SVT_PARAMS}"
else
    SVTAV1_PARAMS="tune=0"
fi

if [ $COPY_HDR ]; then
    ## REFERENCES
    # https://codecalamity.com/encoding-uhd-4k-hdr10-videos-with-ffmpeg/
    ## THIS IS A DANK ASS TRICK THAT MAKES VARIABLES OUT OF ALL THE VIDEO METADATA
    eval "$($FFPROBE -hide_banner -loglevel warning -select_streams v -print_format json -show_frames -read_intervals "%+#1" -show_entries "frame=hdr_format,color_range,color_space,color_primaries,color_transfer,side_data_list,pix_fmt" -i "${INPUT}" | ${GREP} -v -e frames -e '{' -e '\[' -e '}' -e '\]' -e 'side' | ${SED} -e 's/^\ *//g' -e 's/^"//g' -e 's/\":/:/g' -e 's/:\ /=/g' -e 's/,//g' -e 's/^/video_/g' -e 's/^.*=/\U&/g')"

    VIDEO_COLOR_SPACE_FIXED="${VIDEO_COLOR_SPACE/nc/-ncl}"

    ## Processing up the variables from ffprobe fractions to floats
    VIDEO_GREEN_X_BC=$(echo "scale=4;$VIDEO_GREEN_X" | bc)
    VIDEO_GREEN_Y_BC=$(echo "scale=4;$VIDEO_GREEN_Y" | bc)
    VIDEO_BLUE_X_BC=$(echo "scale=4;$VIDEO_BLUE_X" | bc)
    VIDEO_BLUE_Y_BC=$(echo "scale=4;$VIDEO_BLUE_Y" | bc)
    VIDEO_RED_X_BC=$(echo "scale=4;$VIDEO_RED_X" | bc)
    VIDEO_RED_Y_BC=$(echo "scale=4;$VIDEO_RED_Y" | bc)
    VIDEO_WHITE_POINT_X_BC=$(echo "scale=4;$VIDEO_WHITE_POINT_X" | bc)
    VIDEO_WHITE_POINT_Y_BC=$(echo "scale=4;$VIDEO_WHITE_POINT_Y" | bc)
    VIDEO_MAX_LUMINANCE_BC=$(echo "scale=4;$VIDEO_MAX_LUMINANCE" | bc)
    VIDEO_MIN_LUMINANCE_BC=$(echo "scale=4;$VIDEO_MIN_LUMINANCE" | bc)

    if [ "$VIDEO_COLOR_TRANSFER" = "arib-std-b67" ]; then #HLG
        SVTAV1_PARAMS="${SVTAV1_PARAMS}:color-primaries=${VIDEO_COLOR_PRIMARIES}:transfer-characteristics=${VIDEO_COLOR_TRANSFER}:matrix-coefficients=${VIDEO_COLOR_SPACE_FIXED}"
    elif [ "$VIDEO_COLOR_TRANSFER" = "smpte2084" ]; then #HDR10
        SVTAV1_PARAMS="${SVTAV1_PARAMS}:color-primaries=${VIDEO_COLOR_PRIMARIES}"
        SVTAV1_PARAMS="${SVTAV1_PARAMS}:transfer-characteristics=${VIDEO_COLOR_TRANSFER}"
        SVTAV1_PARAMS="${SVTAV1_PARAMS}:matrix-coefficients=${VIDEO_COLOR_SPACE_FIXED}"

        GREEN="${VIDEO_GREEN_X_BC},${VIDEO_GREEN_Y_BC}"
        BLUE="${VIDEO_BLUE_X_BC},${VIDEO_BLUE_Y_BC}"
        RED="${VIDEO_RED_X_BC},${VIDEO_RED_Y_BC}"
        WHITE_POINT="${VIDEO_WHITE_POINT_X_BC},${VIDEO_WHITE_POINT_Y_BC}"
        LUMINANCE="${VIDEO_MAX_LUMINANCE_BC},${VIDEO_MIN_LUMINANCE_BC}"
        CLL="${VIDEO_MAX_CONTENT},${VIDEO_MAX_AVERAGE}"
        
        SVTAV1_PARAMS="${SVTAV1_PARAMS}:mastering-display=G(${GREEN})B(${BLUE})R(${RED})WP(${WHITE_POINT})L(${LUMINANCE}):content-light=${CLL}"
    else
        echo "Unrecognized color transfer: ${VIDEO_COLOR_TRANSFER}"
        echo "Bailing out."
        exit 1
    fi
fi

VIDEO="-c:V libsvtav1 -pix_fmt ${PIXEL_FORMAT} -preset ${SVT_PRESET} -g ${G} -crf ${CRF} -svtav1-params ${SVTAV1_PARAMS}"

MAPS="-map 0 -map -0:d"
TRAILERS="-c:s copy -max_muxing_queue_size 9999"

ENCODE_FLAGS="${MAPS} ${VIDEO} ${AUDIO_FLAGS} ${TRAILERS}"

if [ ! -z "$DURATION" ]; then
    ENCODE_FLAGS="$ENCODE_FLAGS -t $DURATION"
fi

if [ ! -z "$START" ]; then
    FFMPEG="$FFMPEG -ss $START"
fi

if [ $SDR ]; then
    #tonemap=tonemap=mobius:desat=0
    #VF="zscale=t=linear:npl=100,format=gbrpf32le,zscale=p=bt709,tonemap=tonemap=hable:desat=0,zscale=t=bt709:m=bt709:r=tv${VF:+,${VF}}"
    VF="zscale=t=linear:npl=100,format=gbrpf32le,zscale=p=bt709,tonemap=tonemap=mobius:desat=0,zscale=t=bt709:m=bt709:r=full${VF:+,${VF}}"
fi

SCANTYPE=`$MEDIAINFO "$INPUT" | grep "Scan type " | awk -F:\  '{print $2}'`
SCANORDER=`$MEDIAINFO "$INPUT" | grep "Scan order " | awk -F:\  '{print $2}'`
DEINT_SUM=$(( ${YADIF:-0} + ${NNEDI:-0} ))
if [ $DEINT_SUM -gt 1 ]; then
    echo "Pick one deinterlace option, not more than one."
    exit 1
elif [ $(( ${DEINT_SUM:-0} + ${IVTC:-0} + ${IVTC_FIELDMATCH:-0} )) -gt 1 ]; then
    echo "Don't deinterlace and also detelecine, that's bad."
    exit 1
elif [ $YADIFMODE ] && [ -z "$YADIF" ]; then
    echo "Don't set yadifmode if you're not using yadif."
    exit 1
elif [ $YADIF ]; then
    YADIFMODE=${YADIFMODE:=1}
    if [ "$SCANTYPE" = "Interlaced" ] || [ "$SCANTYPE" = "MBAFF" ] || [ "$SCANTYPE" = "PAFF" ]; then
        if [ "$SCANORDER" = "Top Field First" ]; then
            VF="yadif=${YADIFMODE}:0:0${VF:+,${VF}}"
        else
            VF="yadif=${YADIFMODE}:1:0${VF:+,${VF}}"
        fi
    else
        if [ $DEBUG ]; then
            echo "Input video is not interlaced, skipping deint"
        fi
    fi
elif [ $NNEDI ]; then
    NNEDI_WEIGHTS=${FFMPEG_PREFIX}/etc/nnedi3_weights.bin
    NN_DEINT="all"
    FIELD="af"
    PLANES="7"
    NSIZE="s48x6"
    NNS="n64"
    QUAL="slow"
    ETYPE="a"
    PSCRN="new3"
    THREADS=16
    VF="nnedi=$NNEDI_WEIGHTS:deint=$NN_DEINT:field=$FIELD:planes=$PLANES:nsize=$NSIZE:nns=$NNS:qual=$QUAL:etype=$ETYPE:pscrn=${PSCRN}:threads=${THREADS}${VF:+,${VF}}"
fi

if [ $(( ${IVTC:-0} + ${IVTC_FIELDMATCH:-0} )) -gt 1 ]; then
    echo "Can't do both kinds of detelecine at the same time, friend."
    exit 1
elif [ $IVTC ]; then
    VF="pullup,dejudder${VF:+,${VF}} -r 24000/1001"
elif [ $IVTC_FIELDMATCH ]; then
    if [ "$SCANORDER" = "Top Field First" ]; then
        VF="fieldmatch=order=tff:combmatch=full,yadif=deint=interlaced,decimate${VF:+,${VF}}"
    else
        VF="fieldmatch=order=bff:combmatch=full,yadif=deint=interlaced,decimate${VF:+,${VF}}"
    fi
fi

if [ ! -z "$VIDEOFILTER" ]; then
    VF="$VIDEOFILTER${VF:+,${VF}}"
fi

if [ ! -z "$VF" ]; then
    ENCODE_FLAGS="$ENCODE_FLAGS -vf $VF"
fi

if [ $DEBUG ]; then
    echo "COMMANDS:"
    echo "$STRIPCOVERS \"${INPUT}\""
    echo "nice -n 5 $FFMPEG -i \"$INPUT\" $ENCODE_FLAGS \"$OUTPUT\""
    echo "$STRIPTAGS \"${OUTPUT}\""
    echo "$ADDSTATS \"${OUTPUT}\""
    #exit
    read -p "Press y to encode, any other key to exit..." confirm
    case $confirm in
        [Yy] ) true;;
        * ) exit;;
    esac
fi

echo "## Stripping covers from input file..."
echo "$STRIPCOVERS \"${INPUT}\""
$STRIPCOVERS "${INPUT}"
## Can't check status on this, if there are no covers in the file, it exits 1
#if [ $? -eq 0 ]; then
#    echo "## Covers stripped."
#else
#    echo "## error stripping covers."
#    exit 1
#fi

echo "## Starting encode..."
echo "nice -n 5 $FFMPEG -i \"$INPUT\" $ENCODE_FLAGS \"$OUTPUT\""
nice -n 5 $FFMPEG -i "$INPUT" $ENCODE_FLAGS "$OUTPUT"
if [ $? -eq 0 ]; then
    echo "## encode complete."
else
    echo "## encoding error."
    exit 1
fi

echo "## Stripping tags from \"${OUTPUT}\"..."
echo "$STRIPTAGS $(printf "%q" "${OUTPUT}")"
$STRIPTAGS "${OUTPUT}"
if [ $? -eq 0 ]; then
    echo "## Tags stripped from \"${OUTPUT}\""
else
    echo "## error stripping tags from \"${OUTPUT}\""
    exit 1
fi

echo "## Adding stats to \"${OUTPUT}\"..."
echo "$ADDSTATS $(printf "%q" "${OUTPUT}")"
$ADDSTATS "${OUTPUT}" 
if [ $? -eq 0 ]; then 
    echo "## Stats added to \"${OUTPUT}\""
else
    echo "## error adding stats to \"${OUTPUT}\""
    exit 1
fi
